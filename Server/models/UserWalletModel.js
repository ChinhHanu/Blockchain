const ATransaction = require("./TransactionModel");
const Transaction = new ATransaction();
const Cryptography = require('../../common/cryptography');
const EC = require('elliptic').ec;
const ec = new EC('secp256k1');


class Wallet {
  constructor(walletId, publicKey, privateKey, balance) {
    this.walletId = walletId;
    this.publicKey = publicKey;
    this.privateKey = privateKey;
    this.balance = balance;
  }

  sign(dataHash) {
    var keyPair = ec.keyFromPrivate(this.privateKey, 'hex');
    console.log(23, keyPair)

    return keyPair.sign(dataHash);
  }

  createTransaction(recipient, amount, transactionPool) {
    let balance = this.calculateBalanceAvailable(transactionPool);
    console.log(22, "userwallet model " + this.balance);
    if (amount > balance) {
      console.log(24, transaction);
      return;
    }
    let transaction = Transaction.newTransaction(this, recipient, amount);
    transactionPool.addTransaction(transaction);
    return transaction;
  }

  calculateBalanceAvailable(transactionPool) {
    let time = 0;
    let transactions = transactionPool.transactions;

    const walletInputTransactions = transactions.filter(
      transaction => transaction.input.address === this.publicKey
    );

    if (walletInputTransactions.length > 0) {
      const recentInputTransaction = walletInputTransactions.reduce(
        (prev, current) =>
          prev.input.timestamp > current.input.timestamp ? prev : current
      );
      this.balance = recentInputTransaction.outputs.find(
        output => output.address === this.publicKey
      ).amount;
      time = recentInputTransaction.input.timestamp;
    }

    transactions.forEach(transaction => {
      if (transaction.input.timestamp > time) {
        transaction.outputs.find(output => {
          if (output.address === this.publicKey) {
            this.balance = Number(this.balance) + Number(output.amount);
            // console.log(54, "wallet model" + balance);
          }
        });
      }
    });
    return this.balance;
  }

  calculateBalance(blockchain, real_balance) {
    // store the existing balance
    let balance = real_balance;

    // create an array of transactions
    let transactions = [];

    // store all the transactions in the array
    blockchain.forEach(block =>
      transactions.push(block.transaction)
    );

    // get all the transactions generated by the wallet ie money sent by the wallet
    const walletInputTransactions = transactions.filter(
      transaction => transaction.input.address === this.publicKey
    );

    // declare a variable to save the timestamp
    let startTime = 0;

    if (walletInputTransactions.length > 0) {
      // get the latest transaction
      const recentInputTransaction = walletInputTransactions.reduce(
        (prev, current) =>
          prev.input.timestamp > current.input.timestamp ? prev : current
      );

      // get the outputs of that transactions, its amount will be the money that we would get back
      balance = recentInputTransaction.outputs.find(
        output => output.address === this.publicKey
      ).amount;

      // save the timestamp of the latest transaction made by the wallet
      startTime = recentInputTransaction.input.timestamp;
    }

    // get the transactions that were addressed to this wallet ie somebody sent some moeny
    // and add its ouputs.
    // since we save the timestamp we would only add the outputs of the transactions recieved
    // only after the latest transactions made by us

    transactions.forEach(transaction => {
      if (transaction.input.timestamp > startTime) {
        transaction.outputs.find(output => {
          if (output.address === this.publicKey) {
            balance = Number(balance) + Number(output.amount);
          }
        });
      }
    });
    return balance;
  }
}

module.exports = Wallet;
